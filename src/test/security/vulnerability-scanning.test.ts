import { describe, test, expect, beforeEach } from 'vitest';
import { VulnerabilityScanner } from '../../lib/services/vulnerabilityScanner';
import type { ScanConfiguration, VulnerabilityResult } from '../../lib/services/vulnerabilityScanner';
import { testUtils, createMockVulnerability } from './security-test-setup';

describe('Vulnerability Scanning Tests', () => {
  let scanner: VulnerabilityScanner;

  beforeEach(() => {
    scanner = VulnerabilityScanner.getInstance();
    testUtils.clearMockData();
  });

  describe('Basic Vulnerability Scanning', () => {
    test('should perform a complete vulnerability scan with default configuration', async () => {
      // Setup mock vulnerabilities
      const mockVulns = [
        createMockVulnerability({ severity: 'critical', type: 'dependency' }),
        createMockVulnerability({ severity: 'high', type: 'security_header' }),
        createMockVulnerability({ severity: 'medium', type: 'api_endpoint' })
      ];
      testUtils.setMockVulnerabilities(mockVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: true,
        include_api_endpoints: true,
        include_configuration: true,
        include_code_patterns: true,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config, 'test-user');

      expect(result).toBeDefined();
      expect(result.scan_id).toMatch(/^test_scan_\d+$/);
      expect(result.scan_type).toBe('manual');
      expect(result.status).toBe('completed');
      expect(result.vulnerabilities).toHaveLength(3);
      expect(result.summary.total_vulnerabilities).toBe(3);
      expect(result.summary.critical_count).toBe(1);
      expect(result.summary.high_count).toBe(1);
      expect(result.summary.medium_count).toBe(1);
    });

    test('should filter vulnerabilities by severity threshold', async () => {
      // Setup vulnerabilities with different severities
      const mockVulns = [
        createMockVulnerability({ severity: 'critical' }),
        createMockVulnerability({ severity: 'high' }),
        createMockVulnerability({ severity: 'medium' }),
        createMockVulnerability({ severity: 'low' })
      ];
      testUtils.setMockVulnerabilities(mockVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'high',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config);

      // Should only include critical and high severity vulnerabilities
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.vulnerabilities.every(v => v.severity === 'critical' || v.severity === 'high')).toBe(true);
    });

    test('should handle empty vulnerability results', async () => {
      // No mock vulnerabilities set, should return empty results
      testUtils.setMockVulnerabilities([]);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: true,
        include_api_endpoints: true,
        include_configuration: true,
        include_code_patterns: true,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.summary.total_vulnerabilities).toBe(0);
      expect(result.summary.critical_count).toBe(0);
      expect(result.status).toBe('completed');
    });
  });

  describe('Dependency Vulnerability Scanning', () => {
    test('should detect dependency vulnerabilities', async () => {
      const dependencyVulns = [
        createMockVulnerability({
          type: 'dependency',
          severity: 'critical',
          title: 'Critical NPM Vulnerability',
          description: 'Vulnerable dependency detected in package.json',
          cve: 'CVE-2023-1234',
          cvss_score: 9.8
        }),
        createMockVulnerability({
          type: 'dependency',
          severity: 'high',
          title: 'High Risk Dependency',
          description: 'Outdated package with known vulnerabilities',
          cve: 'CVE-2023-5678'
        })
      ];
      testUtils.setMockVulnerabilities(dependencyVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'deep'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities.every(v => v.type === 'dependency')).toBe(true);
      expect(result.vulnerabilities.some(v => v.cve === 'CVE-2023-1234')).toBe(true);
      expect(result.vulnerabilities.some(v => v.cvss_score === 9.8)).toBe(true);
    });

    test('should include remediation recommendations for dependencies', async () => {
      const dependencyVuln = createMockVulnerability({
        type: 'dependency',
        severity: 'high',
        recommendations: ['Update to version 2.1.0 or higher', 'Consider alternative packages']
      });
      testUtils.setMockVulnerabilities([dependencyVuln]);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities[0].recommendations).toContain('Update to version 2.1.0 or higher');
      expect(result.vulnerabilities[0].recommendations).toContain('Consider alternative packages');
    });
  });

  describe('Security Headers Scanning', () => {
    test('should detect missing security headers', async () => {
      const headerVulns = [
        createMockVulnerability({
          type: 'security_header',
          severity: 'medium',
          title: 'Missing Content Security Policy',
          description: 'CSP header not found or improperly configured'
        }),
        createMockVulnerability({
          type: 'security_header',
          severity: 'high',
          title: 'Missing HSTS Header',
          description: 'HTTP Strict Transport Security header missing'
        })
      ];
      testUtils.setMockVulnerabilities(headerVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: false,
        include_security_headers: true,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities.every(v => v.type === 'security_header')).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('Content Security Policy'))).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('HSTS'))).toBe(true);
    });
  });

  describe('API Endpoint Security Scanning', () => {
    test('should detect API endpoint vulnerabilities', async () => {
      const apiVulns = [
        createMockVulnerability({
          type: 'api_endpoint',
          severity: 'high',
          title: 'Unprotected API Endpoint',
          description: 'API endpoint lacks proper authentication',
          location: '/api/users'
        }),
        createMockVulnerability({
          type: 'api_endpoint',
          severity: 'medium',
          title: 'Excessive Data Exposure',
          description: 'API returns sensitive data without filtering',
          location: '/api/admin/users'
        })
      ];
      testUtils.setMockVulnerabilities(apiVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: false,
        include_security_headers: false,
        include_api_endpoints: true,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'deep'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities.every(v => v.type === 'api_endpoint')).toBe(true);
      expect(result.vulnerabilities.some(v => v.location === '/api/users')).toBe(true);
      expect(result.vulnerabilities.some(v => v.location === '/api/admin/users')).toBe(true);
    });
  });

  describe('Configuration Security Scanning', () => {
    test('should detect configuration vulnerabilities', async () => {
      const configVulns = [
        createMockVulnerability({
          type: 'configuration',
          severity: 'critical',
          title: 'Default Database Password',
          description: 'Database using default or weak credentials',
          location: 'database.config.js'
        }),
        createMockVulnerability({
          type: 'configuration',
          severity: 'medium',
          title: 'Debug Mode Enabled',
          description: 'Application running in debug mode in production',
          location: '.env'
        })
      ];
      testUtils.setMockVulnerabilities(configVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: false,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: true,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities.every(v => v.type === 'configuration')).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('Default Database Password'))).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('Debug Mode'))).toBe(true);
    });
  });

  describe('Code Pattern Security Scanning', () => {
    test('should detect insecure code patterns', async () => {
      const codeVulns = [
        createMockVulnerability({
          type: 'code_pattern',
          severity: 'high',
          title: 'SQL Injection Risk',
          description: 'Dynamic SQL query construction detected',
          location: 'src/models/User.ts:45'
        }),
        createMockVulnerability({
          type: 'code_pattern',
          severity: 'medium',
          title: 'Hardcoded Secret',
          description: 'API key or secret found in source code',
          location: 'src/config/api.ts:12'
        })
      ];
      testUtils.setMockVulnerabilities(codeVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: false,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: true,
        severity_threshold: 'low',
        scan_depth: 'deep'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities.every(v => v.type === 'code_pattern')).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('SQL Injection'))).toBe(true);
      expect(result.vulnerabilities.some(v => v.title.includes('Hardcoded Secret'))).toBe(true);
    });
  });

  describe('Scan Performance and Metadata', () => {
    test('should provide accurate scan metadata', async () => {
      const mockVulns = [createMockVulnerability()];
      testUtils.setMockVulnerabilities(mockVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: true,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'standard'
      };

      const result = await scanner.performScan(config, 'security-tester');

      expect(result.metadata.scanner_version).toBe('1.0.0');
      expect(result.metadata.target_environment).toBe('development');
      expect(result.metadata.scanned_components).toContain('dependencies');
      expect(result.summary.scan_duration_ms).toBe(5000);
      expect(result.summary.scan_coverage).toBe(85);
    });

    test('should track scan timing correctly', async () => {
      testUtils.setMockVulnerabilities([]);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'low',
        scan_depth: 'surface'
      };

      const startTime = Date.now();
      const result = await scanner.performScan(config);
      const endTime = Date.now();

      expect(result.started_at).toBeInstanceOf(Date);
      expect(result.completed_at).toBeInstanceOf(Date);
      expect(result.completed_at.getTime()).toBeGreaterThanOrEqual(result.started_at.getTime());
      expect(result.summary.scan_duration_ms).toBe(5000); // Mock returns 5000ms
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('should handle scan configuration edge cases', async () => {
      testUtils.setMockVulnerabilities([]);

      // Test with all scan types disabled
      const config: ScanConfiguration = {
        include_dependency_scan: false,
        include_security_headers: false,
        include_api_endpoints: false,
        include_configuration: false,
        include_code_patterns: false,
        severity_threshold: 'critical',
        scan_depth: 'surface'
      };

      const result = await scanner.performScan(config);

      expect(result.status).toBe('completed');
      expect(result.vulnerabilities).toHaveLength(0);
      expect(result.metadata.scanned_components).toHaveLength(0);
    });

    test('should handle high volume vulnerability results', async () => {
      // Generate many mock vulnerabilities
      const manyVulns = Array.from({ length: 100 }, (_, i) => 
        createMockVulnerability({
          id: `vuln_${i}`,
          severity: i % 4 === 0 ? 'critical' : i % 3 === 0 ? 'high' : i % 2 === 0 ? 'medium' : 'low'
        })
      );
      testUtils.setMockVulnerabilities(manyVulns);

      const config: ScanConfiguration = {
        include_dependency_scan: true,
        include_security_headers: true,
        include_api_endpoints: true,
        include_configuration: true,
        include_code_patterns: true,
        severity_threshold: 'low',
        scan_depth: 'deep'
      };

      const result = await scanner.performScan(config);

      expect(result.vulnerabilities).toHaveLength(100);
      expect(result.summary.total_vulnerabilities).toBe(100);
      expect(result.summary.critical_count).toBeGreaterThan(0);
      expect(result.summary.high_count).toBeGreaterThan(0);
      expect(result.summary.medium_count).toBeGreaterThan(0);
      expect(result.summary.low_count).toBeGreaterThan(0);
    });
  });
}); 