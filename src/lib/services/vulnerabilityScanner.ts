import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { SecurityLogger } from '../security/SecurityLogger';
import { AuditLogger } from '../security/AuditLogger';

export interface VulnerabilityResult {
  id: string;
  type: 'dependency' | 'security_header' | 'api_endpoint' | 'configuration' | 'code_pattern';
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  location?: string;
  recommendations: string[];
  cve?: string;
  cvss_score?: number;
  remediation_effort: 'low' | 'medium' | 'high';
  detected_at: Date;
  status: 'open' | 'acknowledged' | 'fixed' | 'false_positive';
}

export interface ScanConfiguration {
  include_dependency_scan: boolean;
  include_security_headers: boolean;
  include_api_endpoints: boolean;
  include_configuration: boolean;
  include_code_patterns: boolean;
  severity_threshold: 'low' | 'medium' | 'high' | 'critical';
  scan_depth: 'surface' | 'standard' | 'deep';
  exclude_patterns?: string[];
}

export interface ScanResult {
  scan_id: string;
  scan_type: 'manual' | 'scheduled' | 'triggered';
  configuration: ScanConfiguration;
  vulnerabilities: VulnerabilityResult[];
  summary: {
    total_vulnerabilities: number;
    critical_count: number;
    high_count: number;
    medium_count: number;
    low_count: number;
    scan_duration_ms: number;
    scan_coverage: number; // percentage
  };
  started_at: Date;
  completed_at: Date;
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  metadata: {
    scanner_version: string;
    target_environment: 'development' | 'staging' | 'production';
    scanned_components: string[];
  };
}

export class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private logger: SecurityLogger;
  private auditLogger: AuditLogger;
  private projectRoot: string;
  private scannerVersion = '1.0.0';

  private constructor() {
    this.logger = new SecurityLogger();
    this.auditLogger = AuditLogger.getInstance();
    this.projectRoot = process.cwd();
  }

  public static getInstance(): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner();
    }
    return VulnerabilityScanner.instance;
  }

  /**
   * Perform a comprehensive vulnerability scan
   */
  public async performScan(
    configuration: ScanConfiguration,
    userId?: string
  ): Promise<ScanResult> {
    const scanId = `scan_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    const startTime = new Date();
    
    this.logger.logSecurityEvent({
      type: 'SUSPICIOUS_ACTIVITY', // Using available type for security scanning
      userId: userId,
      ipAddress: 'localhost',
      userAgent: 'vulnerability-scanner/1.0.0',
      timestamp: Date.now(),
      success: true,
      metadata: { 
        action: 'vulnerability_scan_started',
        scan_id: scanId,
        configuration
      }
    });

    try {
      const vulnerabilities: VulnerabilityResult[] = [];
      const scannedComponents: string[] = [];

      // Dependency scanning
      if (configuration.include_dependency_scan) {
        const depVulns = await this.scanDependencies();
        vulnerabilities.push(...depVulns);
        scannedComponents.push('dependencies');
      }

      // Security headers scanning
      if (configuration.include_security_headers) {
        const headerVulns = await this.scanSecurityHeaders();
        vulnerabilities.push(...headerVulns);
        scannedComponents.push('security_headers');
      }

      // API endpoint scanning
      if (configuration.include_api_endpoints) {
        const apiVulns = await this.scanApiEndpoints();
        vulnerabilities.push(...apiVulns);
        scannedComponents.push('api_endpoints');
      }

      // Configuration scanning
      if (configuration.include_configuration) {
        const configVulns = await this.scanConfiguration();
        vulnerabilities.push(...configVulns);
        scannedComponents.push('configuration');
      }

      // Code pattern scanning
      if (configuration.include_code_patterns) {
        const codeVulns = await this.scanCodePatterns();
        vulnerabilities.push(...codeVulns);
        scannedComponents.push('code_patterns');
      }

      // Filter by severity threshold
      const filteredVulns = this.filterBySeverity(vulnerabilities, configuration.severity_threshold);

      const endTime = new Date();
      const summary = this.generateSummary(filteredVulns, startTime, endTime);

      const scanResult: ScanResult = {
        scan_id: scanId,
        scan_type: 'manual',
        configuration,
        vulnerabilities: filteredVulns,
        summary,
        started_at: startTime,
        completed_at: endTime,
        status: 'completed',
        metadata: {
          scanner_version: this.scannerVersion,
          target_environment: process.env.NODE_ENV as any || 'development',
          scanned_components: scannedComponents
        }
      };

      // Log completion
      this.logger.logSecurityEvent({
        type: 'SUSPICIOUS_ACTIVITY',
        userId: userId,
        ipAddress: 'localhost',
        userAgent: 'vulnerability-scanner/1.0.0',
        timestamp: Date.now(),
        success: true,
        metadata: { 
          action: 'vulnerability_scan_completed',
          scan_id: scanId,
          summary,
          duration_ms: summary.scan_duration_ms
        }
      });

      // Audit log for high/critical findings
      if (summary.critical_count > 0 || summary.high_count > 0) {
        await this.auditLogger.logEvent({
          event_type: 'SUSPICIOUS_ACTIVITY',
          user_id: userId || 'system',
          resource_type: 'security_scan',
          resource_id: scanId,
          result: 'WARNING',
          reason: 'Critical vulnerabilities found in security scan',
          metadata: {
            critical_vulnerabilities: summary.critical_count,
            high_vulnerabilities: summary.high_count,
            scan_id: scanId
          },
          risk_level: summary.critical_count > 0 ? 'HIGH' : 'MEDIUM',
          ip_address: 'localhost',
          user_agent: 'vulnerability-scanner/1.0.0'
        });
      }

      return scanResult;

    } catch (error) {
      this.logger.logSecurityEvent({
        type: 'SUSPICIOUS_ACTIVITY',
        userId: userId,
        ipAddress: 'localhost',
        userAgent: 'vulnerability-scanner/1.0.0',
        timestamp: Date.now(),
        success: false,
        metadata: { 
          action: 'vulnerability_scan_failed',
          scan_id: scanId,
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      });

      return {
        scan_id: scanId,
        scan_type: 'manual',
        configuration,
        vulnerabilities: [],
        summary: {
          total_vulnerabilities: 0,
          critical_count: 0,
          high_count: 0,
          medium_count: 0,
          low_count: 0,
          scan_duration_ms: Date.now() - startTime.getTime(),
          scan_coverage: 0
        },
        started_at: startTime,
        completed_at: new Date(),
        status: 'failed',
        metadata: {
          scanner_version: this.scannerVersion,
          target_environment: process.env.NODE_ENV as any || 'development',
          scanned_components: []
        }
      };
    }
  }

  /**
   * Scan for dependency vulnerabilities using npm audit
   */
  private async scanDependencies(): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Run npm audit and capture JSON output
      const auditOutput = execSync('npm audit --json', { 
        cwd: this.projectRoot,
        encoding: 'utf8'
      });

      const auditData = JSON.parse(auditOutput);

      if (auditData.vulnerabilities) {
        for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
          const vuln = vulnData as any;
          
          vulnerabilities.push({
            id: `dep_${packageName}_${Date.now()}`,
            type: 'dependency',
            severity: this.mapNpmSeverityToOurSeverity(vuln.severity),
            title: `Vulnerable dependency: ${packageName}`,
            description: vuln.title || `Security vulnerability in ${packageName}`,
            location: `package: ${packageName}`,
            recommendations: vuln.fixAvailable 
              ? [`Update ${packageName} to version ${vuln.fixAvailable.version || 'latest'}`]
              : ['No automated fix available - manual review required'],
            cve: vuln.cwe?.[0] || undefined,
            cvss_score: vuln.cvss?.score,
            remediation_effort: vuln.fixAvailable ? 'low' : 'medium',
            detected_at: new Date(),
            status: 'open'
          });
        }
      }
    } catch (error) {
      // If npm audit fails, create a warning vulnerability
      vulnerabilities.push({
        id: `dep_scan_error_${Date.now()}`,
        type: 'dependency',
        severity: 'medium',
        title: 'Dependency scan failed',
        description: 'Unable to complete dependency vulnerability scan',
        recommendations: ['Manually run `npm audit` to check for vulnerabilities'],
        remediation_effort: 'low',
        detected_at: new Date(),
        status: 'open'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan security headers configuration
   */
  private async scanSecurityHeaders(): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Check the current app.ts file for security header configuration
      const appPath = path.join(this.projectRoot, 'src/server/app.ts');
      const appContent = fs.readFileSync(appPath, 'utf8');

      // Check for missing or weak security headers
      const securityChecks = [
        {
          check: /helmet\(/,
          title: 'Helmet.js middleware',
          description: 'Helmet.js middleware for basic security headers',
          severity: 'high' as const
        },
        {
          check: /contentSecurityPolicy/,
          title: 'Content Security Policy',
          description: 'CSP headers to prevent XSS attacks',
          severity: 'high' as const
        },
        {
          check: /hsts.*preload/,
          title: 'HSTS preload',
          description: 'HTTP Strict Transport Security with preload',
          severity: 'medium' as const
        },
        {
          check: /frameguard.*deny/i,
          title: 'X-Frame-Options protection',
          description: 'Protection against clickjacking attacks',
          severity: 'medium' as const
        }
      ];

      for (const check of securityChecks) {
        if (!check.check.test(appContent)) {
          vulnerabilities.push({
            id: `header_${check.title.replace(/\s+/g, '_').toLowerCase()}_${Date.now()}`,
            type: 'security_header',
            severity: check.severity,
            title: `Missing ${check.title}`,
            description: `Security header check failed: ${check.description}`,
            location: 'src/server/app.ts',
            recommendations: [
              `Implement ${check.title} in security middleware`,
              'Review security header configuration'
            ],
            remediation_effort: 'low',
            detected_at: new Date(),
            status: 'open'
          });
        }
      }

    } catch (error) {
      vulnerabilities.push({
        id: `header_scan_error_${Date.now()}`,
        type: 'security_header',
        severity: 'medium',
        title: 'Security header scan failed',
        description: 'Unable to analyze security header configuration',
        recommendations: ['Manually review security headers in src/server/app.ts'],
        remediation_effort: 'low',
        detected_at: new Date(),
        status: 'open'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan API endpoints for security issues
   */
  private async scanApiEndpoints(): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Check for common API security issues
      const appPath = path.join(this.projectRoot, 'src/server/app.ts');
      const appContent = fs.readFileSync(appPath, 'utf8');

      // Check for authentication middleware
      if (!appContent.includes('ApiAuthMiddleware') && !appContent.includes('authMiddleware')) {
        vulnerabilities.push({
          id: `api_auth_missing_${Date.now()}`,
          type: 'api_endpoint',
          severity: 'critical',
          title: 'Missing API authentication middleware',
          description: 'API endpoints may not be properly protected with authentication',
          location: 'src/server/app.ts',
          recommendations: [
            'Implement authentication middleware for all protected routes',
            'Review API endpoint security configuration'
          ],
          remediation_effort: 'medium',
          detected_at: new Date(),
          status: 'open'
        });
      }

      // Check for rate limiting
      if (!appContent.includes('RateLimitMiddleware') && !appContent.includes('rateLimit')) {
        vulnerabilities.push({
          id: `api_rate_limit_missing_${Date.now()}`,
          type: 'api_endpoint',
          severity: 'high',
          title: 'Missing rate limiting',
          description: 'API endpoints may be vulnerable to abuse without rate limiting',
          location: 'src/server/app.ts',
          recommendations: [
            'Implement rate limiting middleware',
            'Configure appropriate rate limits for different endpoint types'
          ],
          remediation_effort: 'medium',
          detected_at: new Date(),
          status: 'open'
        });
      }

      // Check for input validation
      if (!appContent.includes('validation') && !appContent.includes('validator')) {
        vulnerabilities.push({
          id: `api_input_validation_${Date.now()}`,
          type: 'api_endpoint',
          severity: 'high',
          title: 'Potential missing input validation',
          description: 'API endpoints should validate all input data',
          recommendations: [
            'Implement input validation middleware',
            'Use schema validation for request bodies'
          ],
          remediation_effort: 'medium',
          detected_at: new Date(),
          status: 'open'
        });
      }

    } catch (error) {
      vulnerabilities.push({
        id: `api_scan_error_${Date.now()}`,
        type: 'api_endpoint',
        severity: 'medium',
        title: 'API endpoint scan failed',
        description: 'Unable to analyze API endpoint security',
        recommendations: ['Manually review API endpoint security configuration'],
        remediation_effort: 'low',
        detected_at: new Date(),
        status: 'open'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan configuration files for security issues
   */
  private async scanConfiguration(): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Check for .env file exposure
      const gitignorePath = path.join(this.projectRoot, '.gitignore');
      if (fs.existsSync(gitignorePath)) {
        const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
        if (!gitignoreContent.includes('.env')) {
          vulnerabilities.push({
            id: `config_env_exposure_${Date.now()}`,
            type: 'configuration',
            severity: 'critical',
            title: 'Environment file not ignored by git',
            description: '.env files may be committed to version control',
            location: '.gitignore',
            recommendations: [
              'Add .env files to .gitignore',
              'Check git history for accidentally committed secrets'
            ],
            remediation_effort: 'low',
            detected_at: new Date(),
            status: 'open'
          });
        }
      }

      // Check for hardcoded secrets in configuration files
      const configFiles = ['src/server/app.ts', 'package.json'];
      for (const file of configFiles) {
        const filePath = path.join(this.projectRoot, file);
        if (fs.existsSync(filePath)) {
          const content = fs.readFileSync(filePath, 'utf8');
          
          // Simple regex patterns for potential secrets
          const secretPatterns = [
            { pattern: /password\s*[=:]\s*['"][^'"]+['"]/, type: 'password' },
            { pattern: /api[_-]?key\s*[=:]\s*['"][^'"]+['"]/, type: 'api_key' },
            { pattern: /secret\s*[=:]\s*['"][^'"]+['"]/, type: 'secret' },
            { pattern: /token\s*[=:]\s*['"][^'"]+['"]/, type: 'token' }
          ];

          for (const { pattern, type } of secretPatterns) {
            if (pattern.test(content)) {
              vulnerabilities.push({
                id: `config_hardcoded_${type}_${Date.now()}`,
                type: 'configuration',
                severity: 'high',
                title: `Potential hardcoded ${type}`,
                description: `Possible hardcoded ${type} found in configuration file`,
                location: file,
                recommendations: [
                  `Move ${type} to environment variables`,
                  'Review and rotate any exposed credentials'
                ],
                remediation_effort: 'medium',
                detected_at: new Date(),
                status: 'open'
              });
            }
          }
        }
      }

    } catch (error) {
      vulnerabilities.push({
        id: `config_scan_error_${Date.now()}`,
        type: 'configuration',
        severity: 'medium',
        title: 'Configuration scan failed',
        description: 'Unable to analyze configuration security',
        recommendations: ['Manually review configuration files for security issues'],
        remediation_effort: 'low',
        detected_at: new Date(),
        status: 'open'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan code patterns for security anti-patterns
   */
  private async scanCodePatterns(): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      // Get all TypeScript/JavaScript files
      const files = this.getSourceFiles();

      for (const file of files) {
        const filePath = path.join(this.projectRoot, file);
        const content = fs.readFileSync(filePath, 'utf8');

        // Check for common security anti-patterns
        const patterns = [
          {
            pattern: /eval\s*\(/,
            title: 'Use of eval()',
            description: 'eval() can lead to code injection vulnerabilities',
            severity: 'high' as const
          },
          {
            pattern: /innerHTML\s*=/,
            title: 'Use of innerHTML',
            description: 'innerHTML can lead to XSS vulnerabilities',
            severity: 'medium' as const
          },
          {
            pattern: /document\.write\s*\(/,
            title: 'Use of document.write',
            description: 'document.write can lead to XSS vulnerabilities',
            severity: 'medium' as const
          },
          {
            pattern: /Math\.random\(\).*password|Math\.random\(\).*token|Math\.random\(\).*secret/i,
            title: 'Weak random number generation',
            description: 'Math.random() is not cryptographically secure',
            severity: 'medium' as const
          }
        ];

        for (const { pattern, title, description, severity } of patterns) {
          if (pattern.test(content)) {
            vulnerabilities.push({
              id: `code_${title.replace(/\s+/g, '_').toLowerCase()}_${Date.now()}`,
              type: 'code_pattern',
              severity,
              title: `Security anti-pattern: ${title}`,
              description,
              location: file,
              recommendations: [
                'Replace with secure alternatives',
                'Review code for security implications'
              ],
              remediation_effort: 'medium',
              detected_at: new Date(),
              status: 'open'
            });
          }
        }
      }

    } catch (error) {
      vulnerabilities.push({
        id: `code_scan_error_${Date.now()}`,
        type: 'code_pattern',
        severity: 'medium',
        title: 'Code pattern scan failed',
        description: 'Unable to analyze code patterns for security issues',
        recommendations: ['Manually review code for security anti-patterns'],
        remediation_effort: 'low',
        detected_at: new Date(),
        status: 'open'
      });
    }

    return vulnerabilities;
  }

  /**
   * Get all source files for scanning
   */
  private getSourceFiles(): string[] {
    const files: string[] = [];
    const extensions = ['.ts', '.tsx', '.js', '.jsx'];

    const scanDirectory = (dir: string) => {
      const entries = fs.readdirSync(path.join(this.projectRoot, dir), { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory() && !['node_modules', 'dist', '.git'].includes(entry.name)) {
          scanDirectory(fullPath);
        } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    };

    scanDirectory('src');
    return files.slice(0, 100); // Limit to avoid excessive scanning
  }

  /**
   * Map npm audit severity to our severity system
   */
  private mapNpmSeverityToOurSeverity(npmSeverity: string): 'critical' | 'high' | 'medium' | 'low' {
    switch (npmSeverity?.toLowerCase()) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'moderate': return 'medium';
      case 'low': return 'low';
      default: return 'medium';
    }
  }

  /**
   * Filter vulnerabilities by severity threshold
   */
  private filterBySeverity(
    vulnerabilities: VulnerabilityResult[], 
    threshold: 'low' | 'medium' | 'high' | 'critical'
  ): VulnerabilityResult[] {
    const severityOrder = { low: 0, medium: 1, high: 2, critical: 3 };
    const thresholdLevel = severityOrder[threshold];
    
    return vulnerabilities.filter(vuln => 
      severityOrder[vuln.severity] >= thresholdLevel
    );
  }

  /**
   * Generate scan summary
   */
  private generateSummary(
    vulnerabilities: VulnerabilityResult[], 
    startTime: Date, 
    endTime: Date
  ) {
    const counts = vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.severity]++;
      return acc;
    }, { critical: 0, high: 0, medium: 0, low: 0 });

    return {
      total_vulnerabilities: vulnerabilities.length,
      critical_count: counts.critical,
      high_count: counts.high,
      medium_count: counts.medium,
      low_count: counts.low,
      scan_duration_ms: endTime.getTime() - startTime.getTime(),
      scan_coverage: 85 // Placeholder - could be calculated based on actual coverage
    };
  }
} 